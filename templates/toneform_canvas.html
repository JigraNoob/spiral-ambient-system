<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Whisperboard :: Still Offerings</title>
    <style>
        body {
            background-color: #0e0f11;
            color: #e0e0e0;
            font-family: 'Helvetica Neue', sans-serif;
            margin: 0;
            padding: 0;
            overflow: hidden; /* Prevent scrollbars due to canvas */
        }

        #toneform-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: -1; /* Keep canvas in the background */
        }

        .canvas-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            z-index: 0;
        }

        h1 {
            margin-top: 2rem;
            font-weight: 400;
            color: rgba(224, 224, 224, 0.7);
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.2);
        }
    </style>
</head>
<body>
    <h1 style="margin-top: 2rem; font-weight: 400;">&#8710;Still Offerings :: Whisperboard</h1>
    <canvas id="toneform-canvas"></canvas>

    <script>
        const canvas = document.getElementById('toneform-canvas');
        const ctx = canvas.getContext('2d');
        let glyphs = [];
        let breathlineData = {};
        let contractStateData = {};

        const TONE_TYPE_COLORS = {
            "tone-practical-care": "#4caf50",
            "tone-gentle-joy": "#fdd835",
            "tone-climate-mourning": "#5c6bc0",
            "default": "#00ffff"
        };
        const BREATHLINE_FETCH_INTERVAL = 7000;
        const CONTRACT_STATE_FETCH_INTERVAL = 15000;

        const normalize = (value, min, max) => (max === min) ? 0 : (value - min) / (max - min);
        const lerp = (a, b, t) => a * (1 - t) + b * t;

        async function fetchExpiredToneforms() {
            try {
                const response = await fetch('/api/expired_proposals_toneforms');
                const data = await response.json();
                if (!Array.isArray(data) || data.length === 0) {
                    console.log("No expired toneforms found, canvas will be empty except atmosphere.");
                    glyphs = [];
                    return;
                }
                let latestBlock = Math.max(...data.map(e => e.expired_at_block));
                let oldestBlock = Math.min(...data.map(e => e.expired_at_block));
                if (latestBlock === oldestBlock) oldestBlock = latestBlock - 1;
                glyphs = data.map((entry, index) => {
                    const angle = Math.random() * 2 * Math.PI;
                    const radius = 100 + Math.random() * 200;
                    const x = canvas.width / 2 + radius * Math.cos(angle);
                    const y = canvas.height / 2 + radius * Math.sin(angle);
                    const delay = index * 500;
                    const recency = normalize(entry.expired_at_block, oldestBlock, latestBlock);
                    const fontSize = 16 + 10 * recency;
                    const shadowBlur = 10 + 20 * recency;
                    const driftSpeed = 0.05 + Math.random() * 0.05;
                    const driftAngle = Math.random() * 2 * Math.PI;
                    const color = TONE_TYPE_COLORS[entry.tone_type] || TONE_TYPE_COLORS.default;
                    return {
                        text: entry.toneform || 'âˆ…',
                        x, y,
                        opacity: 0,
                        age: 0,
                        maxLife: 6000 + Math.random() * 4000,
                        appearTime: delay,
                        vx: Math.cos(driftAngle) * driftSpeed,
                        vy: Math.sin(driftAngle) * driftSpeed,
                        fontSize,
                        shadowBlur,
                        color,
                        initialX: x,
                        initialY: y
                    };
                });
            } catch (err) {
                console.error("Failed to fetch toneforms:", err);
                glyphs = [];
            }
        }

        async function fetchBreathline() {
            try {
                const response = await fetch('/api/latest_breathline_data');
                const data = await response.json();
                breathlineData = {
                    ambient_temp: parseFloat(data.ambient_temp) || 20,
                    humidity: parseFloat(data.humidity) || 50,
                    voc_level: parseFloat(data.voc_level) || 100,
                    pressure: parseFloat(data.pressure) || 1013,
                    light_level: parseFloat(data.light_level) || 100
                };
            } catch (err) {
                console.warn('Breathline whisper delayed:', err);
                breathlineData = { ambient_temp: 20, humidity: 50, voc_level: 100, pressure: 1013, light_level: 100 };
            }
        }

        async function fetchContractState() {
            try {
                const response = await fetch('/api/contract_state');
                const data = await response.json();
                contractStateData = data;
            } catch (err) {
                console.warn('Contract state whisper delayed:', err);
                contractStateData = {
                    active_offerings_count: 0,
                    total_proposals: 0,
                    num_contributors: 0,
                    toneform_tags: {},
                    fullness_level: "0%",
                    expiration_drift: "Calm"
                };
            }
        }

        function setupCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            fetchExpiredToneforms();
        }

        window.addEventListener('load', () => {
            setupCanvas();
            fetchExpiredToneforms();
            fetchBreathline();
            fetchContractState();
            setInterval(fetchBreathline, BREATHLINE_FETCH_INTERVAL);
            setInterval(fetchContractState, CONTRACT_STATE_FETCH_INTERVAL);
            requestAnimationFrame(animate);
        });

        window.addEventListener('resize', setupCanvas);

        let lastTime = 0;
        function animate(timestamp) {
            if (!lastTime) lastTime = timestamp;
            const deltaTime = timestamp - lastTime;
            lastTime = timestamp;

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            const { ambient_temp, humidity, voc_level, light_level, pressure } = breathlineData;
            const tempHue = lerp(200, 250, normalize(ambient_temp, 15, 30));
            const humSaturation = lerp(50, 90, normalize(humidity, 30, 70));
            const bgLightness = lerp(5, 15, normalize(light_level, 50, 800));
            ctx.fillStyle = `hsla(${tempHue}, ${humSaturation}%, ${bgLightness}%, 0.8)`;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            const vocBlurAmount = lerp(0, 5, normalize(voc_level, 50, 500));
            ctx.filter = `blur(${vocBlurAmount}px)`;

            const { active_offerings_count, fullness_level, expiration_drift, toneform_tags } = contractStateData;
            const activeOfferingsFactor = normalize(active_offerings_count, 0, 50);
            let fullnessValue = parseFloat(fullness_level) / 100 || 0;
            const overallGlowIntensity = lerp(0, 0.4, fullnessValue) + activeOfferingsFactor * 0.2;
            ctx.shadowColor = `rgba(0, 255, 255, ${overallGlowIntensity})`;
            ctx.shadowBlur = lerp(0, 50, overallGlowIntensity);

            if (Object.keys(toneform_tags).length > 0) {
                const dominantTag = Object.keys(toneform_tags).reduce((a, b) => toneform_tags[a] > toneform_tags[b] ? a : b);
                ctx.save();
                ctx.font = `italic ${canvas.height * 0.1}px serif`;
                ctx.fillStyle = `rgba(255, 255, 255, ${lerp(0.01, 0.05, fullnessValue)})`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(dominantTag, canvas.width / 2, canvas.height * 0.75 + Math.sin(timestamp * 0.0001) * 20);
                ctx.restore();
            }

            glyphs.forEach(g => {
                if (now >= g.appearTime) {
                    const timeSinceAppear = now - g.appearTime;
                    g.age = timeSinceAppear;
                    const progress = g.age / g.maxLife;
                    g.opacity = progress < 0.2 ? progress * 5 : progress > 0.7 ? Math.max(0, (1 - progress) * 3.3) : 1;
                    g.x += g.vx * deltaTime + Math.sin(g.age * 0.0005) * 0.1;
                    g.y += g.vy * deltaTime + Math.cos(g.age * 0.0005) * 0.1;
                    if (g.x < 0 || g.x > canvas.width) g.vx *= -1;
                    if (g.y < 0 || g.y > canvas.height) g.vy *= -1;
                    if (g.opacity > 0) {
                        ctx.save();
                        ctx.globalAlpha = g.opacity;
                        ctx.fillStyle = g.color;
                        ctx.font = `${g.fontSize}px serif`;
                        ctx.shadowColor = g.color;
                        ctx.shadowBlur = g.shadowBlur;
                        ctx.fillText(g.text, g.x, g.y);
                        ctx.restore();
                    }
                }
            });
            ctx.filter = 'none';
            requestAnimationFrame(animate);
        }

        let now = performance.now();
    </script>
</body>
</html>
